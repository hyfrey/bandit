{"name":"Bandit","tagline":"A mulitarmed bandit to A/B test go projects, or other languages via an HTTP API. It uses a log based data flow. Based on John Myles Whites' book \"Bandit Algorithms for Website Optimization\"","body":"[![Build Status](https://travis-ci.org/purzelrakete/bandit.png?branch=master)](https://travis-ci.org/purzelrakete/bandit)\r\n[![Coverage Status](https://coveralls.io/repos/purzelrakete/bandit/badge.png)](https://coveralls.io/r/purzelrakete/bandit)\r\n\r\nA mulitarmed bandit to A/B test go projects, or other languages via an HTTP API.\r\nIt uses a log-based data flow.\r\nBased on John Myles White's [Bandit Algorithms for Website Optimization](http://shop.oreilly.com/product/0636920027393.do).\r\nFull documentation is available [on godoc](http://godoc.org/github.com/purzelrakete/bandit).\r\n\r\nYou can see a general introduction to [Multiarmed Bandits] [1] here.\r\n\r\nBuild bandit with `make`. You need go >= 1.1.1..\r\n\r\n## Data Flow\r\n\r\nA bandit instance is embedded into e.g. an HTTP server. Incoming requests select\r\na variant from an experiment, and then log that selection. Subsequent positive\r\nfeedback from that selection, e.g. a click, is also logged.\r\n\r\nPeriodically, `bandit-job` aggregates selections and rewards from the logs, re-\r\ncalculates variant distribution, and emits a snapshot file to some  shared\r\nstorage. The bandit polls for updates to that snapshot file and hot-reloads the\r\ndistribution on change.\r\n\r\n```\r\n+----------+           +----------+                +------------+\r\n| Bandit   |--select-->| Log      |- - periodic - >| bandit-job |\r\n| instance |--reward-->| storage  |                |            |\r\n+----------+           +----------+                +------------+\r\n     ^                                                    |\r\n     |                 +----------+                       |\r\n     '---------poll----| Snapshot |<----------------------'\r\n                       +----------+\r\n```\r\n\r\n`bandit-job` expects log lines in the following format:\r\n\r\n```\r\n1379257984 BanditSelection shape-20130822:1\r\n1379257987 BanditReward shape-20130822:1 0.000000\r\n```\r\n\r\nNotice that the reward line includes the variant tag. It is up to you to\r\ntransport this tag through your system.\r\n\r\n## Types\r\n\r\nA Bandit is used to select arms and update arms with reward information:\r\n\r\n```go\r\ntype Bandit interface {\r\n  SelectArm() int\r\n  Update(arm int, reward float64)\r\n}\r\n```\r\n\r\nYou will probably not use bandits directly. Instead, a Bandit is put to work\r\ninside an Experiment. You set up experiments (e.g. signup form buttons) with as\r\nmany variants as you like (e.g. blue button, red button):\r\n\r\n```\r\n  +--------+            +---------------+      periodic job\r\n  | Bandit | 1 <----- 1 | Snapshot file | <--- aggregates logs\r\n  +--------+            +---------------+      into counters\r\n      1\r\n      ^\r\n      |\r\n      1\r\n+------------+         +---------+\r\n| Experiment | 1 --> * | Variant |\r\n|------------|         |---------|\r\n| name       |         | tag     |\r\n+------------+         | url     |\r\n                       +---------+\r\n```\r\n\r\n## Integrating and running experiments\r\n\r\nTo use a bandit, you first have to define an experiment and its variants. This\r\nis currently configured as a TSV with a name, URL, and tag. See experiments.tsv\r\nfor an example.\r\n\r\nChoose the best integration for your project depending on whether you have\r\na client side javascript application, a go project, or a project in some other\r\nlanguage.\r\n\r\n### Integration with Javascript and the HTTP API\r\n\r\nRun `bandit-api -port 80 -apiExperiments experiments.tsv` to start the\r\nendpoint with the provided test experiments.\r\n\r\nIn this scenario, the application makes a request to the API endpoint and\r\nthen a second request to your API.\r\n\r\n```\r\n             Bandit HTTP API\r\nJavascript   Select   Reward   Your API\r\n----------   ------   ------   --------\r\n     |-------->|                  |\r\n     |<--------|                  |\r\n     |                            |\r\n     |--------------------------->|\r\n     |<---------------------------|\r\n     :\r\n   later\r\n     :\r\n     |----------------->|\r\n     |<-----------------|\r\n```\r\n\r\nGet a variant from the HTTP API first:\r\n\r\n    GET https://api/experiements/widgets?uid=11 HTTP/1.0\r\n\r\nThe API responds with a variant:\r\n\r\n    HTTP/1.0 200 OK\r\n    Content-Type: text/json\r\n\r\n    {\r\n      uid: 11,\r\n      experiment: \"widgets\",\r\n      url: \"https://api/widget?color=blue\"\r\n      tag: \"widget-sauce-flf89\"\r\n    }\r\n\r\nThe client can now follow up with a request to the returned widget:\r\n\r\n    GET https://api/widget?color=blue HTTP/1.0\r\n\r\nSee the exampe binary and example/index.html for a running example.\r\n\r\n### Integration in another language using the HTTP API\r\n\r\nLaunch the HTTP API as above. When you get a request to your endpoint, make\r\na backend request to the HTTP API. Use the returned variant to vary.\r\n\r\n### Integration with Go projects\r\n\r\nFirst, load an experiment.\r\n\r\n```go\r\n\r\nexperiments := bandit.NewFileOpener(\"experiments.tsv\")\r\ne, err := bandit.NewExperiment(experiments, \"shape-20130822\")\r\nif err != nil {\r\n  log.Fatalf(\"could not construct experiment: %s\", err.Error())\r\n}\r\n\r\nsnapshot := bandit.NewFileOpener(\"shape-20130822.tsv\")\r\nif err := e.InitDelayedBandit(snapshot, 3 * time.Hours); err != nil {\r\n  log.Fatalf(\"could initialize bandits: %s\", err.Error())\r\n}\r\n\r\nfmt.Println(e.Variants)\r\n```\r\n\r\nInitialize your own variant code if necessary. Then, serve. In each request,\r\nselect a variant via the experiment and serve it. Be sure to include the tag\r\nin the response, so your clients can pass it back with rewards.\r\n\r\n# Miscellaneous information\r\n\r\n## Aggregating Logs\r\n\r\nIn a production setting logs are aggregated as described in Data Flow. You\r\ncan use `bandit-job` as a streaming map reduce job with `bandit-job -kind map`\r\nand `bandit-job -kind reduce`. You can also run over the logs wiht `bandit-job\r\n-kind poll`. See `bandit-job -h` for information.\r\n\r\n## Bandit Algorithms\r\n\r\nYou can currently choose between Epsilon Greedy, UCB1 and Softmax. See the\r\ngodoc for detailed information.\r\n\r\n## Simulation\r\n\r\nThe `bandit/sim` package includes the facility to simulate and plot\r\nexperiemnts. You should run your own simulations before putting experiments\r\ninto production. See the sim package for details. You can run bandit-plot\r\nto see some out of the box simulations.\r\n\r\n# Status\r\n\r\nVersion: 0.0.0-alpha.1\r\n\r\nThe API is currently *not stable* and is subject to change at any time.\r\n\r\n## TODO\r\n\r\n- UCB with extensions for delayed rewards\r\n- Sticky assignements\r\n\r\n# Credits\r\n\r\nDeveloped by\r\n\r\n- Rany Keddo (@purzelrakete)\r\n\r\nThanks to for advice and opinions to\r\n\r\n- John Myles White\r\n- Josh Devins\r\n- OzgÃ¼r Demir\r\n- Peter Bourgon\r\n- Sean Braithwaite\r\n\r\n[1]: http://goo.gl/wQkSga \"Multiarmed Bandits\"\r\n[2]: http://dl.acm.org/citation.cfm?id=1677012 \"Explore/Exploit Schemes for Web Content Optimzation\"\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}